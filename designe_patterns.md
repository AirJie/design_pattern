# C++设计模式
设计模式可以化为三类：创建型模式、行为型模式、结构性模式
##  创建型模式:
* 针对创建对象模式设计，单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式
    * 单例模式：确保只有一个实例，并提供一个对象安全访问接口
        * “饿汉模式”:一开始就创建对象,线程安全
        ```c++
        class Singleton {
        public:
        Single* Instance() { reutrn instance_; }
        private:
        Singleton() {}
        static Singleton instance_;
        };
        Singleton instance;//一开始就创建实例对象 
        ```

      * "懒汉模式":只有在调用到时候，再去创建，线程不安全，存在内存泄漏的问题
      ```
      class Singleton {
      public:
      Singleton& operator=(const Singleton&) = delete;
      Singleton(const Singleton &) = delete;
      Singleton& Instance() {
      static Singleton instance;
      return instance;
      }
      private:
      Singleton() {}
      };
      ```
      该种方式单例通过利用C++11种Magic static特性来为实例化中实现线程安全性(局部静态变量初始化有:变量的初始化在第一次声明的地方进行，初始化过程中发生异常视为未完成初始化，当前线程执行到初始化变量的地方时，如有其它线程正在执行该变量的初始化，则当前线程将会阻塞，直到初始化完成为止)
  * 建造者模式：将一个复杂对象的构建与其表示分离，使得同样的构建可以创建不同的表示
      * 适用场景：隔离复杂对象的创建和使用，相同的方法，不同的创建顺序，不同的事件结果
      * 多个部件可以装配到一个对象中，但产生的运行结果不相同
      * 产品类非常复杂或产品类因为调用顺序不同而产生不同作用
      * builder模式不适合创建差异性很大的产品类
  * 工厂方法模式：让子类决定创建的对象
  * 抽象工厂：创建多个产品族的产品对象
  * 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象
      * 使用场景：当一个系统应该独立于他的产品创建、构成和表示时，需要用原型模式； 当实例化的类实在运行时刻指定时，如通过动态装载； 为了避免创建一个与产品类层次平行的工厂类层次时
      * 原型模式对比于拷贝构造的意义：原型模式生产的新对象可能是一个派生类，利用多态特性可以在获取Base*的情况下生成想要克隆的派生对象，而拷贝函数生成的对象只能是类的本身。原型模式是描述一个通用方法，它不管是如何实现的，而拷贝构造则是描述了一个具体的实现方法
## 行为模型
* Adapter Pattern:
    * 意义：
        * 将类的接口转换为客户端所期望的那样，实现兼容性问题(类如各国电源标准不同，需要通过适配器来兼容适配);
        * 用一个新类包装一个现有的类；
        * 阻抗使得旧元件与新系统相匹配
    * 结构：
        * ![Adapter](./picture/adapter.png)
        * Target:客户直接调用类，该类中的Request不符合客户端使用要求
        * Adaptee：客户期待使用的特殊Request接口
        * Adapter：提供一个中间环节，继承了Request接口，并重新封装了Adaptee的SpecificRequest
* Bridge Pattern：
    * 意义：将抽象和实现分离解耦合，两者可以独立变化；在继承中发布接口，并在其继承中下沉实现
    * 结构：
        * ![Bridge](./picture/bridge.png)
        * Abstraction:抽象类,维护一个指向实现类（Implementor）类型的对象的引用
        * Refined Abstraction: 扩展抽象类定义的接口
        * Implementor:实现类定义接口
        * ConcreteImplmentorA/B:具体Implementor的实现类
    * 优劣：
        * 将可能变化的部分单独封装起来，使得变化产生的影响最小，不用编译不必要的第代码
        * 抽象部分和实现部分可以单独的变动，并且每一部分的扩充都不会破坏桥梁模式搭起来架子
        * 实现细节对客户透明
    * 适用：类的实现由多种因素组合决定，不希望抽象和实现有固定的绑定关系，这时可以选着将类的抽象以及实现通过其子类加以扩充

* Composite Pattern：
    * 意义：组合模式将对象组合成树形结构表示整体-部分的结构，Composite允许客户端对单个对象和组合对象具有一致性。模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素
    * Compostite对象结构:
        * ![Composite](./picture/composite.png)
        * Component: 为组合中的对象声明接口； 在适当的情况下，实现所有类共有接口的缺省行为； 声明一个接口用于访问和管理Component的子组件
        * Leaf:在组合中表示叶节点对象，无子节点；在组合中定义图元对象的行为
        * Composite：定义有子部件的行为；实现与子部件相关的操作
        * Client：通过Compment接口操纵组合部件的对象

    * 组合模式有两种形式：透明模式和安全模式。透明模式在客户端看来，叶子节点类和合成类是一致的，只不过叶子节点类提供的子类管理方法(如add、remove等) 无实质意义，而安全模式刚好相反，叶子节点类没有合成类的子类管理方法，客户端来看，两者有不同接口，显得不透明
    * 使用场景： 表示对象的"部分-整体"的层次结构；希望用户忽略组合对象与单个对象的不同

* Decorator Pattern:
    * 意义: 
        * 动态地为对象附加额外的职责，相比生成子类方式，装饰器为扩展功能提供了一种更灵活的方式
        * 通过递归包装核心对象来装饰客户端指定的核心对象
    * 结构：
        * ![Decorator](./picture/decorator.png)
        * Component:抽象组件定义一个对象接口，使得装饰对象能动态加入到组件中。
        * ConcreteComponent:定义一个具体能附加职责的类。
        * Decorator:抽象装饰器，维持组件对象的一个引用，并定义与组件接口一致的接口。
        * ConcreteDecorator:具体装饰器,添加职责给组件。
    * 适用性：
        * 在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责
        * 处理能收回的职责。
        * 当不能通过子类来扩充时。有时候一大堆独立的扩充是可能的，但将激增子类来支持每种扩充间的组合。或者一个类的定义可能被隐藏或不能用于生成子类

* Facade Pattern：
    * 意义：
        * 为子系统提供一组统一的接口，Facade定义了一个更高级的接口，使子系统更易使用。
        * 用更简单的接口包装一个复杂的子系统，一个常见的设计目的是使子系统捡到通信和相互依赖关系达到最小
    * 结构
        * ![Facade](./picture/facade.png)
        * Facade:外观角色，客户端可以调用他的方法，其支持所有底层类的对象，并且包含底层类中所有的方法
        * SubSystem：子系统，相当于多个类的集合
        * Client：客户端，直接使用Facade接口提供的方法
    * 适用性：
        * 当为一个复杂子系统提供一个简单接口时
        * 客户程序与抽象类的实现部分之间存在很大的依赖性
        * 当需要构建一个层次结构的子系统时，适用Facade模式定义子系统中每层入口点，通过facade进行通讯
    * Note:设计应用场景，这个要分三个阶段来说:
        * 在设计初期阶段，应该要有意识的将不同的两个层分离，比如经典的三层架构，就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的层与层之间建立一个外观Facade，这个可以为复杂的子系统提供一个简单的接口，降低耦合。
        * 其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也会产生一些很多的小类，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。
        * 第三，在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须依赖它。你可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。
* Flyweight Pattern：
    * 意义：
        * 使用共享来有效地支持大量细粒度对象
        * 图形界面战略，以取代沉重的小部件
    * 结构
        * ![Flyweight](./picture/flyweight.png)
        * Flyweight：抽象享元类，声明了具体享元类公共的方法，向外界提供享元对象的内部数据(内部状态），同时也可以通过这些方法来设置外部数据(外部状态）
        * ConcreteFlyweight:具体享元类，实现抽象享元类，通常结合单例模式来设计具体享元类，为每个具体的享元类提供唯一对象
        * UnsharedFlyweight: 非共享具体享元类，不能被共享子类
        * FlyweightFactory：享元工厂类，结合工厂模式用于创建并管理享元对象
    * 概述: Flyweight模式中，最重要的是将对象分解成intrinsic(在享元对象内部不随环境变化)和extrinsic(随环境变化)两部分；在Flyweight中，通常修改的是外部状态属性，而内部状态属性一般都是用于参考或计算时引用
    * 优缺点：可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，享元模式的外部状态相对独立，不会影响到内部状态， 从而使得享元对象可以在不同的环境中共享。 享元模式使得系统变得复杂，需要分离出内外部状态，使得程序程序逻辑复杂化；为使对象可以共享，享元模式需要将相应对象的部分状态外部化，而读取外部状态使得运行时间变长
    * 使用场景：
        * 一个系统有大量相同或者相似的对象，造成内存大量消耗
        * 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中
        * 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此应当在需要多次重复使用享元对象时才值得使用享元模式
* private class data :私有类数据模式
    * 意义：    
        * 控制对类的属性的更改
        * 将数据与使用它的方法分离
        * 封装类的初始化数据
        * 提供新类型的final-final后置构造函数
    * 结构：
        * ![PrivateData](./picture/private_data.png)
        * MainClass：根据构造函数列表构造DataClass类的实例
        * DataClass：封装数据
    * 适用场景：
        * 类的初始化数据是一次性的不可修改的数据
        * 需要控制对类的初始化数据的更改
        * 预防对初始化数据的不必要的更改
* Proxy Pattern：代理模式
    * 意义：
        * 为另一个对象提供一个代理或占位符来控制对它的访问
        * 适用额外的间接方式来支持分布式、智能访问
        * 添加包装器和委托，以保证真正的组件不受其他复杂性影响
    * 结构：
        * ![Proxy](./picture/proxy.png)
        * Subject:声明了RealSubject与Proxy的共同接口，定义了某些功能
        * RealSubject：通常执行具体的业务逻辑，Proxy控制对他的访问
        * Proxy：持有一个RealSubject引用(指针）,可以在需要时将请求转发给RealSubject，起到代理作用
        * Client：通过Proxy间接地与RealSubject进行交互
## 行为模式
* Chain of Responsibility Pattern:职责链模式
    * 意义：
        * 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
        * 将接收对象链接起来，并沿着链接方向传递请求，直到一个对象响应请求
        * 使用包含许多可能的处理程序的单个处理管道启动和离开请求。
        * 一个具有递归遍历的面向对象链表
    * 概述：考虑员工要求加薪。公司的管理者一共有三级，总经理、总监、经理，如果一个员工要求加薪，应该向主管的经理申请，如果加薪的数量 在经理的职权内，那么经理可以直接批准，否则将申请上交给总监。总监的处理方式也一样，总经理可以处理所有请求。这就是典型的职责链模式，请求的处理形成 了一条链，直到有一个对象处理请求
    * 结构：
        * ![ChainOfResponsibility](./picture/chain_of_responsibility.png)
        * Handler:定义一个处理请求的接口，如果可以接口可以定义一个方法，以调用具体实现类的方法
        * ConcreteHandle:具体处理者，可以选择请求处理掉，或者下沉给下家 
    * 特点：
        * 职责链的特点是：当客户提交一个请求时，请求是沿链传递直至有一个Manager对象负责处理它。
        * 请求者不用管哪个对象来处理，反正该请求会被处理。它只需保持一个后继者即可。
        * 一个请求到链的最后可能也没有处理，所以一定要配置得当。
* Command Pattern:
    * 意义：
        * 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；
        * 对请求排队或记录请求日志，以及支持可撤销的操作;
        * 在OOP中，一切都是对象，将请求封装成对象，符合OOP的设计思想，当将客户的单个请求封装成对象以后，我们就可以对这个请求存储更多的信息，使请求拥有更多的能力；
        * 命令模式同样能够把请求发送者和接收者解耦，使得命令发送者不用去关心请求将以何种方式被处理;
    * 结构：
        * ![Command](./picture/command.png)
        * Command:声明执行操作的接口；
        * ConcreteCommand:将一个接收者对象与一个动作绑定在一起，之后调用接收者对应的操作，以实现execute来完成相应命令
        * Client：创建一个具体命令对象，但没有指定它的接收者
        * Invoker：要求该命令执行这个请求
        * Receiver:直到如何执行或操作一个请求，任何类都可以作为接收者
        * 以上对象是按照如下流程执行的：
            * Client创建一个ConcreteCommand命令对象，该对象绑定Receiver对象
            * Invoker对象存储该ConcreteCommand
            * 该Invoker通过调用Command的Execute来提交一个请求，如果该请求支持撤销，ConcreteCommand的Execute在执行前保存当前状态，用于取消该命令操作；
            * ConcreteCommand调用Receiver的一些操作以执行请求；
    * 优劣：命令模式的两个重要方面:接口分离(调用方与接收方隔离)、时间分离(存储准备就绪的处理请求，稍后再进行说明)。

* Interpreter Pattern:解释器模式
    * 意义:给予一种编程语言，为它的语法定义一种表现形式并包括一个解释器使用这个形式来解释语言中的语句
    * 结构：
        * ![Interpteter](./picture/interpreter.png)
        * AbstractExpression:声明一个抽闲解释器操作，在抽象语法书中被所有节点所共有
        * TerminalExpression:末端表达式
            * 实现与在语法中与末端符号相关的解释操作
            * 在语句中每个末端符号都需要实例
        * NonteiminalExpression:非末端表达式
            * 在语法中每条规则都需要一个这样的类,\(R::=R_1R_2...R_n\)
            * 从\(R_1)到\(R_n)的每个符号都维护抽象表达式类型的实例变量
            * 实现在语法中非末端表达式的解释操作，解释器通常在\(R_1\)到\(R_n\)表示的变量中递归的自我调用
        * Context：场景类，包含解释器的全局信息
        * Client：
            * 建立表示语法定义的语言中的特殊语句的抽象语法树，这个抽象语法树由非末端表示类和末端表示类装配而成
            * 调用解释器操作
    * 适用场景：当一种语音需要解释，并且能够把语言内语句表示成一棵抽象的语法树时，使用解释器模式,最好应用在：
        * 语法是简单的，
        * 效率不是关键的考虑素。最高效的解释器往往不以直接解释解析树来实现，而是先把它们转换成另外种形式。比如，正则表达式通常被转换成状态机。但即使如此，这个转换器也可以由解析起模式来实现，所以这个模式还是比较实用的
    * 优劣：复杂的语法很难维护。解释器模式为语法中的每条规则定义至少一个类（以 BNF 定义的语法规则可能需要多个类）。因此包含许多规则的语法很难管理和维护。其他设计模式可以应用来消除这个问题（参考 Implementation）。但是当语法非常复杂时，比如解析器或编译生成起之类的其他技术更适合。
* Iterator Pattern:迭代器模式
    * 意义：
        * 提供一种方法按顺序访问聚合对象元素,而无需公开其底层表示;
        * 对于标准库抽象，使得分离集合类和算法成为可能;
    * 结构：
        * ![Iterator](./picture/iterator.png)
        * Iterator:迭代器角色，定义了访问和遍历元素的接口
        * ConcreteIterator: 具体实现迭代器接口
            * 实现迭代器接口。
            * 保存遍历聚合元素的当前位置
        * Aggregate:集合类，提供创建具体迭代器的接口
        * ConcreteAggregate：具体集合类，实现创建具体迭代器，与集合的结构相关
    * 适用场景：
        * 访问一个聚合对象的内容，但却不想暴露它的内部实现。
        * 为聚合对象支持所有遍历方法。
        * 为遍历不同的聚合结构提供一种统一的接口（即，支持多态迭代化）
    * 优劣：
        * 它支持以不同的方式遍历一个聚合对象
        * 迭代器简化了聚合类
        * 在同一个聚合上可以有多个遍历
        * 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码
        * 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性

* Mediator Pattern:
    * 意义：
        * 定义一个对象来封装一组对象如何交互。中介者模式使各个对象不显示的互相引用，并让你独立的改变它们的交互，从而达到提高松耦合的效果
        * 设计一个中介者来解耦许多对等点
        * 将交互对等点多对多的关系提升到"完全对象状态"
    * 结构：
        * ![Mediator](./picture/mediator.png)
* Template Method模式：
    * 意义：
        * 在一个操作定义一个算法框架，将一些步骤延迟到客户端子类，模板方法允许子类在不改变算法结构情况下重新定义算法
        * 基类声明算法的“占位符”,派生类实现算法的占位符
    * 结构
        * ![TemplateMethod](./picture/template_method.png)
